import React, { useState, useEffect, useRef, useCallback } from 'react';

const RetroTypingShooter = () => {
  const [gameState, setGameState] = useState('menu');
  const [mode, setMode] = useState('normal');
  const [score, setScore] = useState(0);
  const [stage, setStage] = useState(1);
  const [defeatedCount, setDefeatedCount] = useState(0);
  const [enemies, setEnemies] = useState([]); // enemiesはReactのstateで管理
  const canvasRef = useRef(null);
  const animationFrameIdRef = useRef(null);
  const gameTimeRef = useRef(0);
  const audioContextRef = useRef(null);
  const bgmIntervalRef = useRef(null);
  const bgmOscillatorsRef = useRef([]);

  // handleKeyPressのようなイベントハンドラで最新のenemiesを参照するためのref
  const enemiesForEventHandlerRef = useRef(enemies);
  useEffect(() => {
    enemiesForEventHandlerRef.current = enemies;
  }, [enemies]);

  const allSentences = [
    { text: 'おはよう', romaji: 'OHAYOU' },
    { text: 'こんにちは', romaji: 'KONNNITIHA' },
    { text: 'こんばんは', romaji: 'KONNBANHA' },
    { text: 'ありがとう', romaji: 'ARIGATOU' },
    { text: 'ごめんなさい', romaji: 'GOMENNNASAI' },
    { text: 'すみません', romaji: 'SUMIMASENN' },
    { text: 'いただきます', romaji: 'ITADAKIMASU' },
    { text: 'ごちそうさま', romaji: 'GOTISOUSAMA' },
    { text: 'ただいま', romaji: 'TADAIMA' },
    { text: 'おかえり', romaji: 'OKAERI' },
    { text: '今日はいい天気ですね', romaji: 'KYOUHAIITENNKIDESUNE' },
    { text: 'お元気ですか', romaji: 'OGENNKIDESUKA' },
    { text: 'はじめまして', romaji: 'HAJIMEMASITE' },
    { text: 'よろしくお願いします', romaji: 'YOROSIKUONEGAISIMASU' },
    { text: 'お疲れ様です', romaji: 'OTUKARESAMADESU' },
    { text: 'いってきます', romaji: 'ITTEKIMASU' },
    { text: 'いってらっしゃい', romaji: 'ITTERASSYAI' },
    { text: 'おやすみなさい', romaji: 'OYASUMINASAI' },
    { text: 'お誕生日おめでとう', romaji: 'OTANNJOUBIOMEDETO' },
    { text: 'がんばって', romaji: 'GANNBATTE' },
    { text: 'お大事に', romaji: 'ODAIJINI' },
    { text: '失礼します', romaji: 'SITUREISIMASU' },
    { text: 'どういたしまして', romaji: 'DOUITASIMASITE' },
    { text: 'お待たせしました', romaji: 'OMATASESIMASITA' },
    { text: '申し訳ございません', romaji: 'MOUSIWAKEGOZAIMASENN' },
    { text: '了解しました', romaji: 'RYOUKAISIMASITA' },
    { text: '承知しました', romaji: 'SYOUTISIMASITA' },
    { text: '確認します', romaji: 'KAKUNINNSIMASU' },
    { text: 'お先に失礼します', romaji: 'OSAKINISITUREISIMASU' },
    { text: '今日も一日頑張りましょう', romaji: 'KYOUMOITINITIGANNBARIMASYOU' },
    { text: 'いい天気ですね', romaji: 'IITENNKIDESUNE' },
    { text: 'お久しぶりです', romaji: 'OHISASIBURIDESU' },
    { text: 'また会いましょう', romaji: 'MATAAIMASYOU' },
    { text: 'お気をつけて', romaji: 'OKIWOTUKETE' },
    { text: 'ご無沙汰しております', romaji: 'GOBUSATASITEIORIMASU' },
    { text: '楽しみにしています', romaji: 'TANOSIMINISITEMASU' },
    { text: 'どうぞお入りください', romaji: 'DOUZOOHAIRIKUDASAI' },
    { text: 'かしこまりました', romaji: 'KASIKOMARIMASITA' },
    { text: 'お手数おかけします', romaji: 'OTESUUOKAKESIMASU' },
    { text: 'ご連絡ありがとうございます', romaji: 'GORENRAKUARIGATOUGOZAIMASU' },
    { text: '素敵な一日を', romaji: 'SUTEKINAITINITIWO' },
    { text: '頑張ってください', romaji: 'GANBATTEKUDASAI' },
    { text: 'お会いできて嬉しいです', romaji: 'OAIDEKITEURESIIDESU' },
    { text: 'ありがとうございました', romaji: 'ARIGATOGOZAIMASITA' },
    { text: 'どうもありがとう', romaji: 'DOUMOARIGATOU' },
    { text: 'とても美味しいです', romaji: 'TOTEMOOISIIDESU' },
    { text: 'お腹が空きました', romaji: 'ONAKAGASUKIMASITA' },
    { text: 'お水をください', romaji: 'OMIZUOWOKUDASAI' },
    { text: 'お会計お願いします', romaji: 'OKAIKEIONEGAISIMASU' },
    { text: 'お時間ありますか', romaji: 'OJIKANARIMASUKA' },
    { text: 'もう一度お願いします', romaji: 'MOUITIDOONEGAISIMASU' },
    { text: '少々お待ちください', romaji: 'SYOUSYOOOMATIKUDASAI' },
    { text: '本当にありがとう', romaji: 'HONTOUNIARIGATOU' },
    { text: '大変申し訳ありません', romaji: 'TAIHENMOUSIWAKEARIMASENN' },
    { text: 'よくわかりません', romaji: 'YOKUWAKARIMASEN' },
    { text: 'もう少しゆっくりお願いします', romaji: 'MOUSUKOSIYUKKURIONEGAISIMASU' },
    { text: '素晴らしいですね', romaji: 'SUBARASIIDESUNE' },
    { text: 'それは面白いですね', romaji: 'SOREHAOMOSIROIDESUNE' },
    { text: 'とても楽しかったです', romaji: 'TOTEMOTANOSIKATTADESU' },
    { text: 'また来ます', romaji: 'MATAKIMASU' },
    { text: 'お見舞い申し上げます', romaji: 'OMIMAIMOUSIAGEMASU' },
    { text: 'お体に気をつけて', romaji: 'OKARADANIKIWOTSUKETE' },
    { text: 'どうぞご自愛ください', romaji: 'DOUZOGOZIAIKUDASAI' },
    { text: '心よりお祈りしています', romaji: 'KOKOROYORIOINORISITEIMASU' },
    { text: 'お仕事頑張ってください', romaji: 'OSIGOTOGANBATTEKUDASAI' },
    { text: '応援しています', romaji: 'OUENSITEIMASU' },
    { text: '成功をお祈りします', romaji: 'SEIKOUWOOINORISIMASU' },
    { text: 'いつもありがとうございます', romaji: 'ITUMOARIGATOUGOZAIMASU' },
    { text: 'お陰様で元気です', romaji: 'OKAGESAMADEGENKIDESU' },
    { text: '順調に進んでいます', romaji: 'JUNTYOUNISUSUNDEIMASU' },
    { text: 'お力添えありがとうございます', romaji: 'OTIKARAZOEARIGATOUGOZAIMASU' },
    { text: 'ご協力感謝します', romaji: 'GOKYOURYOKUKANSYASIMASU' },
    { text: 'また機会がありましたら', romaji: 'MATAKIKAIGARIMASITARA' },
    { text: 'これからもよろしく', romaji: 'KOREKARAMOYOROSIKU' },
    { text: '今後ともよろしくお願いします', romaji: 'KONGOTOMOYOROSIKUONEGAISIMASU' },
    { text: 'お世話になりました', romaji: 'OSEWANINARIMASITA' },
    { text: 'お世話になっております', romaji: 'OSEWANINATTEORIMASU' },
    { text: 'お忙しいところすみません', romaji: 'OISOGASIITOKOROSUMIMASEN' },
    { text: 'お時間をいただきありがとうございます', romaji: 'OJIKANWOITADAKIARIGATOUGOZAIMASU' },
    { text: 'ご都合はいかがですか', romaji: 'GOTUGOUHAIKAGADESUKA' },
    { text: 'ご検討よろしくお願いします', romaji: 'GOKENTOUYOROSIKUONEGAISIMASU' },
    { text: 'ご理解いただけますと幸いです', romaji: 'GORIKAIITADAKEMASUTOSAIWAIDESU' },
    { text: 'お返事お待ちしております', romaji: 'OHENNJIOOMATISITEORIMASU' },
    { text: '取り急ぎご連絡まで', romaji: 'TORIISOGIGORENNRAKUMADE' }
  ];

  const getAudioContext = () => {
    if (!audioContextRef.current) {
      audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
    }
    return audioContextRef.current;
  };

  const playSound = (frequency, duration, type = 'square', volume = 0.1) => {
    try {
      const ctx = getAudioContext();
      if (ctx.state === 'suspended') {
        ctx.resume();
      }
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      
      osc.type = type;
      osc.frequency.value = frequency;
      osc.connect(gain);
      gain.connect(ctx.destination);
      gain.gain.value = volume;
      
      osc.start();
      gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
      osc.stop(ctx.currentTime + duration);
    } catch (e) {
      console.log('Audio error:', e);
    }
  };

  const playMenuSelectSound = useCallback(() => {
    playSound(880, 0.1);
  }, []);

  const playTypeSound = useCallback(() => {
    playSound(1200, 0.05, 'square', 0.05);
  }, []);

  const playDefeatSound = useCallback(() => {
    playSound(440, 0.1);
    setTimeout(() => playSound(880, 0.1), 100);
    setTimeout(() => playSound(1320, 0.2), 200);
  }, []);

  const playGameOverSound = useCallback(() => {
    playSound(400, 0.2);
    setTimeout(() => playSound(350, 0.2), 200);
    setTimeout(() => playSound(300, 0.3), 400);
  }, []);

  const playStageUpSound = useCallback(() => {
    playSound(523, 0.1);
    setTimeout(() => playSound(659, 0.1), 100);
    setTimeout(() => playSound(784, 0.2), 200);
  }, []);

  const startBGM = useCallback(() => {
    stopBGM();
    try {
      const ctx = getAudioContext();
      if (ctx.state === 'suspended') {
        ctx.resume();
      }
      
      const melodyPattern = [
        523.25, 587.33, 659.25, 587.33, 523.25, 493.88, 523.25, 587.33,
        659.25, 698.46, 659.25, 587.33, 523.25, 493.88, 523.25, 440.00
      ];
      
      let currentNoteIndex = 0;
      
      const playBGMNote = () => {
        bgmOscillatorsRef.current.forEach(osc => {
          try {
            osc.stop();
          } catch(e) {}
        });
        bgmOscillatorsRef.current = [];
        
        const freq = melodyPattern[currentNoteIndex % melodyPattern.length];
        
        const osc1 = ctx.createOscillator();
        const gain1 = ctx.createGain();
        osc1.type = 'triangle';
        osc1.frequency.value = freq;
        gain1.gain.value = 0.02;
        osc1.connect(gain1);
        gain1.connect(ctx.destination);
        osc1.start(ctx.currentTime);
        osc1.stop(ctx.currentTime + 0.4);
        
        const osc2 = ctx.createOscillator();
        const gain2 = ctx.createGain();
        osc2.type = 'sine';
        osc2.frequency.value = freq * 0.5;
        gain2.gain.value = 0.015;
        osc2.connect(gain2);
        gain2.connect(ctx.destination);
        osc2.start(ctx.currentTime);
        osc2.stop(ctx.currentTime + 0.4);
        
        bgmOscillatorsRef.current.push(osc1, osc2);
        
        currentNoteIndex++;
      };
      
      playBGMNote();
      bgmIntervalRef.current = setInterval(playBGMNote, 350);
    } catch (e) {
      console.error('BGM error:', e);
    }
  }, [stopBGM]);

  const stopBGM = useCallback(() => {
    if (bgmIntervalRef.current) {
      clearInterval(bgmIntervalRef.current);
      bgmIntervalRef.current = null;
    }
    bgmOscillatorsRef.current.forEach(osc => {
      try {
        osc.stop();
      } catch(e) {}
    });
    bgmOscillatorsRef.current = [];
  }, []);

  const getSentencesForStage = (stageNum) => {
    const length = Math.min(15 + stageNum * 3, 40);
    return allSentences.filter(s => s.text.length <= length);
  };

  const drawDotText = (ctx, text, x, y, size, color) => {
    ctx.fillStyle = color;
    ctx.font = `bold ${size}px "Courier New", monospace`;
    ctx.textAlign = 'center';
    
    ctx.fillStyle = '#000';
    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        if (dx !== 0 || dy !== 0) {
          ctx.fillText(text, x + dx, y + dy);
        }
      }
    }
    
    ctx.fillStyle = color;
    ctx.fillText(text, x, y);
  };

  const drawEnemyShip = (ctx, x, y) => {
    const pixelSize = 5;
    const pattern = [
      [1,0,1,0,1],
      [0,1,1,1,0],
      [1,1,1,1,1],
      [0,1,1,1,0],
      [0,0,1,0,0]
    ];
    
    ctx.fillStyle = '#ff0000';
    pattern.forEach((row, dy) => {
      row.forEach((pixel, dx) => {
        if (pixel) {
          ctx.fillRect(
            x + (dx - 2) * pixelSize,
            y + (dy - 2) * pixelSize,
            pixelSize,
            pixelSize
          );
        }
      });
    });
  };

  // 描画ロジックを分離
  const drawGame = useCallback((ctx, currentEnemies, currentScore, currentStage) => {
    const canvas = ctx.canvas;

    // キャンバスを毎回クリア
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // 背景の星
    ctx.fillStyle = '#444';
    for (let i = 0; i < 100; i++) {
      const x = (i * 79) % canvas.width;
      const y = ((i * 113) + gameTimeRef.current * 0.15) % canvas.height;
      const size = (i % 3) + 1;
      ctx.fillRect(x, y, size, size);
    }

    // グリッド線
    ctx.strokeStyle = '#0a0a0a';
    ctx.lineWidth = 1;
    for (let i = 0; i < canvas.width; i += 50) {
      ctx.beginPath();
      ctx.moveTo(i, 0);
      ctx.lineTo(i, canvas.height);
      ctx.stroke();
    }
    for (let i = 0; i < canvas.height; i += 50) {
      ctx.beginPath();
      ctx.moveTo(0, i);
      ctx.lineTo(canvas.width, i);
      ctx.stroke();
    }

    // プレイヤーエリアの線
    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 3;
    ctx.setLineDash([10, 5]);
    ctx.beginPath();
    ctx.moveTo(0, canvas.height - 50);
    ctx.lineTo(canvas.width, canvas.height - 50);
    ctx.stroke();
    ctx.setLineDash([]);

    // 敵の描画とテキスト
    currentEnemies.forEach(enemy => {
      drawEnemyShip(ctx, enemy.x, enemy.y);

      drawDotText(ctx, enemy.japanese, enemy.x, enemy.y + 45, 20, '#ffffff');

      // テキストの描画位置を調整
      const typedWidth = enemy.typed.length * 7; // 文字の幅に応じて調整
      const remainingWidth = (enemy.word.length - enemy.typed.length) * 7;

      drawDotText(ctx, enemy.typed, enemy.x - remainingWidth / 2 - 5, enemy.y - 30, 14, '#00ff00');
      drawDotText(ctx, enemy.word.substring(enemy.typed.length), enemy.x + typedWidth / 2 + 5, enemy.y - 30, 14, '#ffffff');
    });

    // UIパネル
    ctx.fillStyle = '#001100';
    ctx.fillRect(10, 10, 180, 55);
    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 2;
    ctx.strokeRect(10, 10, 180, 55);
    
    drawDotText(ctx, `SCORE:${currentScore}`, 100, 30, 14, '#00ff00');
    drawDotText(ctx, `STAGE:${currentStage}`, 100, 50, 14, '#00ffff');
  }, []); // 依存配列は空でOK、ゲーム状態は引数で渡すため


  const gameLoop = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) {
      animationFrameIdRef.current = requestAnimationFrame(gameLoop);
      return;
    }
    const ctx = canvas.getContext('2d');
    
    gameTimeRef.current += 1;
    
    // 敵の生成
    setEnemies(prevEnemies => {
      if (gameTimeRef.current % Math.max(180, 400 - stage * 20) === 0 && prevEnemies.length === 0) {
        const availableSentences = getSentencesForStage(stage);
        if (availableSentences.length > 0) {
          const sentence = availableSentences[Math.floor(Math.random() * availableSentences.length)];
          const newEnemy = {
            id: Date.now(),
            word: sentence.romaji,
            japanese: sentence.text,
            x: canvas.width / 2,
            y: -30,
            speed: 0.8 + stage * 0.1,
            typed: ''
          };
          return [...prevEnemies, newEnemy];
        }
      }
      return prevEnemies;
    });

    // 敵の位置更新と衝突判定
    setEnemies(prevEnemies => {
      const updated = prevEnemies.map(enemy => ({
        ...enemy,
        y: enemy.y + enemy.speed
      }));

      const collision = updated.some(enemy => enemy.y > canvas.height - 50);

      if (collision) {
        stopBGM();
        playGameOverSound();
        setGameState('gameover');
        return [];
      }

      return updated.filter(enemy => enemy.y < canvas.height);
    });

    // 描画はuseEffectで行う
    animationFrameIdRef.current = requestAnimationFrame(gameLoop);
  }, [stage, stopBGM, playGameOverSound, getSentencesForStage]); // gameLoopはstageに依存

  // 描画専用のuseEffect
  useEffect(() => {
    if (gameState === 'playing') {
      const canvas = canvasRef.current;
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      
      // 描画関数を呼び出す
      drawGame(ctx, enemies, score, stage);
    }
  }, [enemies, score, stage, gameState, drawGame]); // enemies, score, stageが更新されたら再描画

  useEffect(() => {
    if (gameState === 'playing') {
      const canvas = canvasRef.current;
      if (!canvas) return;

      startBGM();
      animationFrameIdRef.current = requestAnimationFrame(gameLoop);

      return () => {
        if (animationFrameIdRef.current) {
          cancelAnimationFrame(animationFrameIdRef.current);
        }
        stopBGM();
      };
    } else {
      stopBGM();
      // ゲームオーバー画面など、playing以外の状態では描画を停止
      if (animationFrameIdRef.current) {
        cancelAnimationFrame(animationFrameIdRef.current);
        animationFrameIdRef.current = null;
      }
    }
  }, [gameState, gameLoop, startBGM, stopBGM]);

  const handleKeyPress = useCallback((e) => {
    // イベントハンドラでは常に最新のstateを参照するためrefを使用
    if (gameState !== 'playing' || enemiesForEventHandlerRef.current.length === 0) return;

    const key = e.key.toUpperCase();
    
    if (key.length === 1 && key.match(/[A-Z]/)) {
      const currentEnemies = enemiesForEventHandlerRef.current;
      const enemy = currentEnemies[0];
      const expectedChar = enemy.word[enemy.typed.length];
      
      if (expectedChar === key) {
        playTypeSound();
        const newTyped = enemy.typed + key;
        
        if (newTyped === enemy.word) {
          playDefeatSound();
          setDefeatedCount(prev => {
            const newDefeated = prev + 1;
            if (newDefeated >= 10) {
              setStage(s => s + 1);
              playStageUpSound();
              return 0;
            }
            return newDefeated;
          });
          setScore(s => s + 200 + stage * 50);
          setEnemies([]);
        } else {
          setEnemies(prev => prev.map(e => e.id === enemy.id ? { ...e, typed: newTyped } : e));
        }
      } else if (mode === 'hard') {
        stopBGM();
        playGameOverSound();
        setGameState('gameover');
      }
    }
  }, [gameState, mode, playTypeSound, playDefeatSound, playGameOverSound, playStageUpSound, stopBGM, stage]);

  useEffect(() => {
    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [handleKeyPress]);

  const startGame = (selectedMode) => {
    playMenuSelectSound();
    setTimeout(() => {
      setMode(selectedMode);
      setGameState('playing');
      setScore(0);
      setStage(1);
      setDefeatedCount(0);
      setEnemies([]); // ゲーム開始時に敵をリセット
      gameTimeRef.current = 0;
    }, 150);
  };

  const backToMenu = () => {
    playMenuSelectSound();
    setGameState('menu');
  };

  if (gameState === 'menu') {
    return (
      <div className="flex items-center justify-center min-h-screen bg-black text-white">
        <div className="text-center space-y-8 p-8 border-4 border-cyan-500" style={{background: '#001a1a'}}>
          <h1 className="text-5xl font-bold mb-8" style={{fontFamily: 'monospace', color: '#00ffff', textShadow: '4px 4px #004444'}}>
            ■ TYPE FIGHTER ■
          </h1>
          <div className="space-y-4">
            <button
              onClick={() => startGame('normal')}
              className="block w-80 mx-auto px-8 py-4 text-xl font-bold border-4 border-green-500 bg-green-900 hover:bg-green-700 transition-colors"
              style={{fontFamily: 'monospace', textShadow: '2px 2px #000'}}
            >
              ► ノーマルモード
            </button>
            <button
              onClick={() => startGame('hard')}
              className="block w-80 mx-auto px-8 py-4 text-xl font-bold border-4 border-red-500 bg-red-900 hover:bg-red-700 transition-colors"
              style={{fontFamily: 'monospace', textShadow: '2px 2px #000'}}
            >
              ► ハードモード
            </button>
          </div>
          <div className="mt-8 text-sm text-cyan-400 max-w-md mx-auto border-2 border-cyan-800 p-4 bg-black" style={{fontFamily: 'monospace'}}>
            <p>■ 遊び方 ■</p>
            <p className="mt-2">文章をタイピングして撃墜</p>
            <p>10機撃墜でステージアップ</p>
            <p className="mt-3 text-green-400">ノーマル: ミスしてもOK</p>
            <p className="text-red-400">ハード: ミスしたら即死</p>
          </div>
        </div>
      </div>
    );
  }

  if (gameState === 'gameover') {
    return (
      <div className="flex items-center justify-center min-h-screen bg-black text-white">
        <div className="text-center space-y-8 p-8 border-4 border-red-500" style={{background: '#1a0000'}}>
          <h1 className="text-6xl font-bold mb-4" style={{fontFamily: 'monospace', color: '#ff0000', textShadow: '4px 4px #440000'}}>
            ■ GAME OVER ■
          </h1>
          <p className="text-4xl mb-4" style={{fontFamily: 'monospace', color: '#00ffff', textShadow: '3px 3px #004444'}}>
            SCORE: {score}
          </p>
          <p className="text-3xl mb-8" style={{fontFamily: 'monospace', color: '#ffff00'}}>
            STAGE: {stage}
          </p>
          <button
            onClick={backToMenu}
            className="px-8 py-4 text-xl font-bold border-4 border-cyan-500 bg-cyan-900 hover:bg-cyan-700 transition-colors"
            style={{fontFamily: 'monospace', textShadow: '2px 2px #000'}}
          >
            ► メニューに戻る
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="flex items-center justify-center min-h-screen bg-gray-900">
      <canvas
        ref={canvasRef}
        width={700}
        height={700}
        className="border-4 border-cyan-500"
        style={{imageRendering: 'pixelated'}}
      />
    </div>
  );
};

export default RetroTypingShooter;
