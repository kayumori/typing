import React, { useState, useEffect, useRef } from 'react';

const RetroTypingShooter = () => {
  const [gameState, setGameState] = useState('menu');
  const [mode, setMode] = useState('normal');
  const [score, setScore] = useState(0);
  const [stage, setStage] = useState(1);
  const [defeatedCount, setDefeatedCount] = useState(0);
  const [enemies, setEnemies] = useState([]);
  const canvasRef = useRef(null);
  const animationRef = useRef(null);
  const gameTimeRef = useRef(0);
  const audioContextRef = useRef(null);
  const bgmIntervalRef = useRef(null);
  const bgmOscillatorsRef = useRef([]);

  const allSentences = [
    { text: 'おはよう', romaji: 'OHAYOU' },
    { text: 'こんにちは', romaji: 'KONNICHIHA' },
    { text: 'こんばんは', romaji: 'KONBANHA' },
    { text: 'ありがとう', romaji: 'ARIGATOU' },
    { text: 'ごめんなさい', romaji: 'GOMENNASAI' },
    { text: 'すみません', romaji: 'SUMIMASEN' },
    { text: 'いただきます', romaji: 'ITADAKIMASU' },
    { text: 'ごちそうさま', romaji: 'GOCHISOUSAMA' },
    { text: 'ただいま', romaji: 'TADAIMA' },
    { text: 'おかえり', romaji: 'OKAERI' },
    { text: '今日はいい天気ですね', romaji: 'KYOUHAIITENKIDESUNE' },
    { text: 'お元気ですか', romaji: 'OGENKIDESUKA' },
    { text: 'はじめまして', romaji: 'HAJIMEMASHITE' },
    { text: 'よろしくお願いします', romaji: 'YOROSHIKUONEGAISHIMASU' },
    { text: 'お疲れ様です', romaji: 'OTSUKARESAMA' },
    { text: 'いってきます', romaji: 'ITTEKIMASU' },
    { text: 'いってらっしゃい', romaji: 'ITTERASSHAI' },
    { text: 'おやすみなさい', romaji: 'OYASUMINASAI' },
    { text: 'お誕生日おめでとう', romaji: 'OTANJOUBIOMEDETO' },
    { text: 'がんばって', romaji: 'GANBATTE' },
    { text: 'お大事に', romaji: 'ODAIJINI' },
    { text: '失礼します', romaji: 'SHITSUREISHIMASU' },
    { text: 'どういたしまして', romaji: 'DOUITASHIMASHITE' },
    { text: 'お待たせしました', romaji: 'OMATASESHIMASHITA' },
    { text: '申し訳ございません', romaji: 'MOUSHIWAKEGOZAIMASEN' },
    { text: '了解しました', romaji: 'RYOUKAISHIMASHITA' },
    { text: '承知しました', romaji: 'SHOUCHISHIMASHITA' },
    { text: '確認します', romaji: 'KAKUNINSHIMASU' },
    { text: 'お先に失礼します', romaji: 'OSAKINI' },
    { text: '今日も一日頑張りましょう', romaji: 'KYOUMOICHINICHIGANBARIMASHOU' },
    { text: 'いい天気ですね', romaji: 'IITENKIDESUNE' },
    { text: 'お久しぶりです', romaji: 'OHISASHIBURIDESU' },
    { text: 'また会いましょう', romaji: 'MATAAIMASYOU' },
    { text: 'お気をつけて', romaji: 'OKIOTSUKETE' },
    { text: 'ご無沙汰しております', romaji: 'GOBUSATASHITEIMASU' },
    { text: '楽しみにしています', romaji: 'TANOSHIMINISHITEIMASU' },
    { text: 'どうぞお入りください', romaji: 'DOUZOOHAIRI' },
    { text: 'かしこまりました', romaji: 'KASHIKOMARIMASHITA' },
    { text: 'お手数おかけします', romaji: 'OTESUUOKAKESHIMASU' },
    { text: 'ご連絡ありがとうございます', romaji: 'GORENRAKUARIGATOU' },
    { text: '素敵な一日を', romaji: 'SUTEKINAICHINICHIWO' },
    { text: '頑張ってください', romaji: 'GANBATTEKUDASAI' },
    { text: 'お会いできて嬉しいです', romaji: 'OAIDEKITEURESHIIDESU' },
    { text: 'ありがとうございました', romaji: 'ARIGATOUGOZAIMASHITA' },
    { text: 'どうもありがとう', romaji: 'DOUMOARIGATOU' },
    { text: 'とても美味しいです', romaji: 'TOTEOMOOISHIIDESU' },
    { text: 'お腹が空きました', romaji: 'ONAKAGASUKIMASHITA' },
    { text: 'お水をください', romaji: 'OMIZUOKUDASAI' },
    { text: 'お会計お願いします', romaji: 'OKAIKEIONEGAISHIMASU' },
    { text: 'お時間ありますか', romaji: 'OJIKANARIMASU' },
    { text: 'もう一度お願いします', romaji: 'MOUITIDOONEGAISHIMASU' },
    { text: '少々お待ちください', romaji: 'SHOUSHOUOMACHI' },
    { text: '本当にありがとう', romaji: 'HONTOUNIARIGATOU' },
    { text: '大変申し訳ありません', romaji: 'TAIHENMOUSHIWAKE' },
    { text: 'よくわかりません', romaji: 'YOKUWAKARIMNASEN' },
    { text: 'もう少しゆっくりお願いします', romaji: 'MOUSUKOSHIYUKKURI' },
    { text: '素晴らしいですね', romaji: 'SUBARASHIIDESU' },
    { text: 'それは面白いですね', romaji: 'SOREHAOMOSIROIDESUNE' },
    { text: 'とても楽しかったです', romaji: 'TOTEMOTANOSHIKATTA' },
    { text: 'また来ます', romaji: 'MATAKIMASU' },
    { text: 'お見舞い申し上げます', romaji: 'OMIMAIMOUSHIAGEMASU' },
    { text: 'お体に気をつけて', romaji: 'OKARADANIKIOTSUKETE' },
    { text: 'どうぞご自愛ください', romaji: 'DOUZOJIAI' },
    { text: '心よりお祈りしています', romaji: 'KOKOROYORIOINO' },
    { text: 'お仕事頑張ってください', romaji: 'OSHIGOTOGANBATTE' },
    { text: '応援しています', romaji: 'OUENSHITEIMASU' },
    { text: '成功をお祈りします', romaji: 'SEIKOUWOOINORI' },
    { text: 'いつもありがとうございます', romaji: 'ITSUMOARIGATOU' },
    { text: 'お陰様で元気です', romaji: 'OKAGESAMADEGENKI' },
    { text: '順調に進んでいます', romaji: 'JUNCHOUNISUSU' },
    { text: 'お力添えありがとうございます', romaji: 'OCHIKARAZOEARIGATOU' },
    { text: 'ご協力感謝します', romaji: 'GOKYOURYOKUKANSHA' },
    { text: 'また機会がありましたら', romaji: 'MATAKIKAIGARIMASHITARA' },
    { text: 'これからもよろしく', romaji: 'KOREKARAMOYOROSHIKU' },
    { text: '今後ともよろしくお願いします', romaji: 'KONGOTOMOYOROSHIKU' },
    { text: 'お世話になりました', romaji: 'OSEWANINARIMASITA' },
    { text: 'お世話になっております', romaji: 'OSEWANINARIMASU' },
    { text: 'お忙しいところすみません', romaji: 'OISOGASHIITOKORO' },
    { text: 'お時間をいただきありがとうございます', romaji: 'OJIKANWOITADAKI' },
    { text: 'ご都合はいかがですか', romaji: 'GOTSUGOUHAIKAGA' },
    { text: 'ご検討よろしくお願いします', romaji: 'GOKENTOUYOROSHIKU' },
    { text: 'ご理解いただけますと幸いです', romaji: 'GORIKAIITADAKEMASU' },
    { text: 'お返事お待ちしております', romaji: 'OHENJIOMACHI' },
    { text: '取り急ぎご連絡まで', romaji: 'TORIISOGIGORENRAKU' }
  ];

  const getAudioContext = () => {
    if (!audioContextRef.current) {
      audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
    }
    return audioContextRef.current;
  };

  const playSound = (frequency, duration, type = 'square') => {
    try {
      const ctx = getAudioContext();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      
      osc.type = type;
      osc.frequency.value = frequency;
      osc.connect(gain);
      gain.connect(ctx.destination);
      gain.gain.value = 0.1;
      
      osc.start();
      gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
      osc.stop(ctx.currentTime + duration);
    } catch (e) {
      console.log('Audio error:', e);
    }
  };

  const playMenuSelectSound = () => {
    playSound(880, 0.1);
  };

  const playTypeSound = () => {
    playSound(1200, 0.05);
  };

  const playDefeatSound = () => {
    playSound(440, 0.1);
    setTimeout(() => playSound(880, 0.1), 100);
    setTimeout(() => playSound(1320, 0.2), 200);
  };

  const playGameOverSound = () => {
    playSound(400, 0.2);
    setTimeout(() => playSound(350, 0.2), 200);
    setTimeout(() => playSound(300, 0.3), 400);
  };

  const playStageUpSound = () => {
    playSound(523, 0.1);
    setTimeout(() => playSound(659, 0.1), 100);
    setTimeout(() => playSound(784, 0.2), 200);
  };

  const startBGM = () => {
    stopBGM(); // 既存のBGMを停止
    try {
      const ctx = getAudioContext();
      
      // レトロRPG風のメロディパターン
      const melodyPattern = [
        523.25, 587.33, 659.25, 587.33, 523.25, 493.88, 523.25, 587.33,
        659.25, 698.46, 659.25, 587.33, 523.25, 493.88, 523.25, 440.00
      ];
      
      let currentNoteIndex = 0;
      
      const playBGMNote = () => {
        // 古い音を停止
        bgmOscillatorsRef.current.forEach(osc => {
          try {
            osc.stop();
          } catch(e) {}
        });
        bgmOscillatorsRef.current = [];
        
        const freq = melodyPattern[currentNoteIndex % melodyPattern.length];
        
        // メイン音
        const osc1 = ctx.createOscillator();
        const gain1 = ctx.createGain();
        osc1.type = 'triangle';
        osc1.frequency.value = freq;
        gain1.gain.value = 0.01;
        osc1.connect(gain1);
        gain1.connect(ctx.destination);
        osc1.start();
        osc1.stop(ctx.currentTime + 0.4);
        
        // ハーモニー（オクターブ下）
        const osc2 = ctx.createOscillator();
        const gain2 = ctx.createGain();
        osc2.type = 'sine';
        osc2.frequency.value = freq * 0.5;
        gain2.gain.value = 0.008;
        osc2.connect(gain2);
        gain2.connect(ctx.destination);
        osc2.start();
        osc2.stop(ctx.currentTime + 0.4);
        
        bgmOscillatorsRef.current.push(osc1, osc2);
        
        currentNoteIndex++;
      };
      
      playBGMNote();
      bgmIntervalRef.current = setInterval(playBGMNote, 350);
    } catch (e) {
      console.log('BGM error:', e);
    }
  };

  const stopBGM = () => {
    if (bgmIntervalRef.current) {
      clearInterval(bgmIntervalRef.current);
      bgmIntervalRef.current = null;
    }
    bgmOscillatorsRef.current.forEach(osc => {
      try {
        osc.stop();
      } catch(e) {}
    });
    bgmOscillatorsRef.current = [];
  };

  const getSentencesForStage = (stageNum) => {
    const length = Math.min(15 + stageNum * 3, 40);
    return allSentences.filter(s => s.text.length <= length);
  };

  const drawDotText = (ctx, text, x, y, size, color) => {
    ctx.fillStyle = color;
    ctx.font = `bold ${size}px "Courier New", monospace`;
    ctx.textAlign = 'center';
    
    ctx.fillStyle = '#000';
    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        if (dx !== 0 || dy !== 0) {
          ctx.fillText(text, x + dx, y + dy);
        }
      }
    }
    
    ctx.fillStyle = color;
    ctx.fillText(text, x, y);
  };

  const drawEnemyShip = (ctx, x, y) => {
    const pixelSize = 5;
    const pattern = [
      [1,0,1,0,1],
      [0,1,1,1,0],
      [1,1,1,1,1],
      [0,1,1,1,0],
      [0,0,1,0,0]
    ];
    
    ctx.fillStyle = '#ff0000';
    pattern.forEach((row, dy) => {
      row.forEach((pixel, dx) => {
        if (pixel) {
          ctx.fillRect(
            x + (dx - 2) * pixelSize,
            y + (dy - 2) * pixelSize,
            pixelSize,
            pixelSize
          );
        }
      });
    });
  };

  useEffect(() => {
    if (gameState === 'playing') {
      // ゲーム開始時にBGMを開始
      const startDelay = setTimeout(() => {
        startBGM();
      }, 100);
      
      const canvas = canvasRef.current;
      const ctx = canvas.getContext('2d');
      
      const gameLoop = () => {
        gameTimeRef.current += 1;
        
        const spawnInterval = Math.max(300, 500 - stage * 20);
        if (gameTimeRef.current % spawnInterval === 0 && enemies.length === 0) {
          const availableSentences = getSentencesForStage(stage);
          const sentence = availableSentences[Math.floor(Math.random() * availableSentences.length)];
          const newEnemy = {
            id: Date.now(),
            word: sentence.romaji,
            japanese: sentence.text,
            x: canvas.width / 2,
            y: -30,
            speed: 0.05 + stage * 0.005,
            typed: ''
          };
          setEnemies(prev => [...prev, newEnemy]);
        }

        setEnemies(prev => {
          const updated = prev.map(enemy => ({
            ...enemy,
            y: enemy.y + enemy.speed
          }));

          const collision = updated.some(enemy => enemy.y > canvas.height - 50);

          if (collision) {
            stopBGM();
            playGameOverSound();
            setGameState('gameover');
            return [];
          }

          return updated.filter(enemy => enemy.y < canvas.height);
        });

        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = '#444';
        for (let i = 0; i < 100; i++) {
          const x = (i * 79) % canvas.width;
          const y = ((i * 113) + gameTimeRef.current * 0.15) % canvas.height;
          const size = (i % 3) + 1;
          ctx.fillRect(x, y, size, size);
        }

        ctx.strokeStyle = '#0a0a0a';
        ctx.lineWidth = 1;
        for (let i = 0; i < canvas.width; i += 50) {
          ctx.beginPath();
          ctx.moveTo(i, 0);
          ctx.lineTo(i, canvas.height);
          ctx.stroke();
        }

        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 3;
        ctx.setLineDash([10, 5]);
        ctx.beginPath();
        ctx.moveTo(0, canvas.height - 50);
        ctx.lineTo(canvas.width, canvas.height - 50);
        ctx.stroke();
        ctx.setLineDash([]);

        enemies.forEach(enemy => {
          drawEnemyShip(ctx, enemy.x, enemy.y);

          drawDotText(ctx, enemy.japanese, enemy.x, enemy.y + 45, 20, '#ffffff');

          if (enemy.typed) {
            drawDotText(ctx, enemy.typed, enemy.x - (enemy.word.length - enemy.typed.length) * 4, enemy.y - 30, 14, '#00ff00');
          }
          
          const remaining = enemy.word.substring(enemy.typed.length);
          drawDotText(ctx, remaining, enemy.x + enemy.typed.length * 4, enemy.y - 30, 14, '#ffffff');
        });

        ctx.fillStyle = '#001100';
        ctx.fillRect(10, 10, 180, 55);
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 2;
        ctx.strokeRect(10, 10, 180, 55);
        
        drawDotText(ctx, `SCORE:${score}`, 100, 30, 14, '#00ff00');
        drawDotText(ctx, `STAGE:${stage}`, 100, 50, 14, '#00ffff');

        animationRef.current = requestAnimationFrame(gameLoop);
      };

      gameLoop();

      return () => {
        if (animationRef.current) {
          cancelAnimationFrame(animationRef.current);
        }
        if (startDelay) {
          clearTimeout(startDelay);
        }
        stopBGM();
      };
    }
  }, [gameState, enemies, score, stage]);

  const handleKeyPress = (e) => {
    if (gameState !== 'playing' || enemies.length === 0) return;

    const key = e.key.toUpperCase();
    
    if (key.length === 1 && key.match(/[A-Z]/)) {
      const enemy = enemies[0];
      const expectedChar = enemy.word[enemy.typed.length];
      
      if (expectedChar === key) {
        playTypeSound();
        const newTyped = enemy.typed + key;
        
        if (newTyped === enemy.word) {
          playDefeatSound();
          const newDefeatedCount = defeatedCount + 1;
          setDefeatedCount(newDefeatedCount);
          setScore(s => s + 200 + stage * 50);
          setEnemies([]);
          
          if (newDefeatedCount >= 10) {
            setStage(s => s + 1);
            setDefeatedCount(0);
            playStageUpSound();
          }
        } else {
          setEnemies([{ ...enemy, typed: newTyped }]);
        }
      } else if (mode === 'hard') {
        stopBGM();
        playGameOverSound();
        setGameState('gameover');
      }
    }
  };

  useEffect(() => {
    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [gameState, enemies, mode, defeatedCount, stage]);

  const startGame = (selectedMode) => {
    playMenuSelectSound();
    setTimeout(() => {
      setMode(selectedMode);
      setGameState('playing');
      setScore(0);
      setStage(1);
      setDefeatedCount(0);
      setEnemies([]);
      gameTimeRef.current = 0;
    }, 150);
  };

  const backToMenu = () => {
    playMenuSelectSound();
    setGameState('menu');
  };

  if (gameState === 'menu') {
    return (
      <div className="flex items-center justify-center min-h-screen bg-black text-white">
        <div className="text-center space-y-8 p-8 border-4 border-cyan-500" style={{background: '#001a1a'}}>
          <h1 className="text-5xl font-bold mb-8" style={{fontFamily: 'monospace', color: '#00ffff', textShadow: '4px 4px #004444'}}>
            ■ TYPE FIGHTER ■
          </h1>
          <div className="space-y-4">
            <button
              onClick={() => startGame('normal')}
              className="block w-80 mx-auto px-8 py-4 text-xl font-bold border-4 border-green-500 bg-green-900 hover:bg-green-700 transition-colors"
              style={{fontFamily: 'monospace', textShadow: '2px 2px #000'}}
            >
              ► ノーマルモード
            </button>
            <button
              onClick={() => startGame('hard')}
              className="block w-80 mx-auto px-8 py-4 text-xl font-bold border-4 border-red-500 bg-red-900 hover:bg-red-700 transition-colors"
              style={{fontFamily: 'monospace', textShadow: '2px 2px #000'}}
            >
              ► ハードモード
            </button>
          </div>
          <div className="mt-8 text-sm text-cyan-400 max-w-md mx-auto border-2 border-cyan-800 p-4 bg-black" style={{fontFamily: 'monospace'}}>
            <p>■ 遊び方 ■</p>
            <p className="mt-2">文章をタイピングして撃墜</p>
            <p>10機撃墜でステージアップ</p>
            <p className="mt-3 text-green-400">ノーマル: ミスしてもOK</p>
            <p className="text-red-400">ハード: ミスしたら即死</p>
          </div>
        </div>
      </div>
    );
  }

  if (gameState === 'gameover') {
    return (
      <div className="flex items-center justify-center min-h-screen bg-black text-white">
        <div className="text-center space-y-8 p-8 border-4 border-red-500" style={{background: '#1a0000'}}>
          <h1 className="text-6xl font-bold mb-4" style={{fontFamily: 'monospace', color: '#ff0000', textShadow: '4px 4px #440000'}}>
            ■ GAME OVER ■
          </h1>
          <p className="text-4xl mb-4" style={{fontFamily: 'monospace', color: '#00ffff', textShadow: '3px 3px #004444'}}>
            SCORE: {score}
          </p>
          <p className="text-3xl mb-8" style={{fontFamily: 'monospace', color: '#ffff00'}}>
            STAGE: {stage}
          </p>
          <button
            onClick={backToMenu}
            className="px-8 py-4 text-xl font-bold border-4 border-cyan-500 bg-cyan-900 hover:bg-cyan-700 transition-colors"
            style={{fontFamily: 'monospace', textShadow: '2px 2px #000'}}
          >
            ► メニューに戻る
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="flex items-center justify-center min-h-screen bg-gray-900">
      <canvas
        ref={canvasRef}
        width={700}
        height={700}
        className="border-4 border-cyan-500"
        style={{imageRendering: 'pixelated'}}
      />
    </div>
  );
};

export default RetroTypingShooter;
